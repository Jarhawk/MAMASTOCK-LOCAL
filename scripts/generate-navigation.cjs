/* scripts/generate-navigation.cjs */
const fs = require("fs");
const path = require("path");

const cwd = process.cwd();
const SRC_DIR = path.join(cwd, "src");
const REPORTS_INV = path.join(cwd, "reports", "src-inventory.json");
const VAR_INV = path.join(cwd, "var", "src-inventory.json");
const OUT_ROUTER = path.join(SRC_DIR, "router.autogen.tsx");
const OUT_SIDEBAR = path.join(SRC_DIR, "components", "sidebar.autogen.tsx");

function readJsonSafe(p) {
  if (!fs.existsSync(p)) return null;
  try {
    return JSON.parse(fs.readFileSync(p, "utf8"));
  } catch (e) {
    console.error(`✖ Failed to parse JSON: ${p}\n`, e && e.stack || e);
    process.exitCode = 1;
    return null;
  }
}

function scanPagesRoot() {
  const pagesDir = path.join(SRC_DIR, "pages");
  const acc = [];
  function walk(dir) {
    if (!fs.existsSync(dir)) return;
    for (const name of fs.readdirSync(dir)) {
      const full = path.join(dir, name);
      const st = fs.statSync(full);
      if (st.isDirectory()) walk(full);
      else if (/\.(jsx|tsx|js|ts)$/.test(name)) {
        acc.push(full);
      }
    }
  }
  walk(pagesDir);
  return acc;
}

function toRoutePath(absFile) {
  // Turn e.g. src/pages/parametrage/Familles.tsx -> /parametrage/familles
  const rel = path.relative(path.join(SRC_DIR, "pages"), absFile).replace(/\\/g, "/");
  const noExt = rel.replace(/\.(jsx|tsx|js|ts)$/, "");
  const parts = noExt.split("/").map((p,i) => i === 0 ? p.toLowerCase() : p.replace(/\s+/g,"-").toLowerCase());
  let route = "/" + parts.join("/");
  if (route.endsWith("/index")) route = route.slice(0, -"/index".length) || "/";
  return route;
}

function preferTitleFromName(absFile) {
  const base = path.basename(absFile).replace(/\.(jsx|tsx|js|ts)$/,"");
  // Very small title prettifier
  return base
    .replace(/([a-z])([A-Z])/g, "$1 $2")
    .replace(/[-_]+/g, " ")
    .replace(/\b(\w)/g, (m) => m.toUpperCase());
}

function normalizeInventory(inv) {
  // Expected shapes:
  // - { pages: [{ file, route?, title? }], ... }
  // - or raw list of files
  const pages = [];

  if (inv && Array.isArray(inv.pages)) {
    for (const p of inv.pages) {
      if (!p || !p.file) continue;
      const abs = path.isAbsolute(p.file) ? p.file : path.join(cwd, p.file);
      pages.push({
        file: abs,
        route: p.route || toRoutePath(abs),
        title: p.title || preferTitleFromName(abs),
      });
    }
  } else if (Array.isArray(inv)) {
    for (const f of inv) {
      const abs = path.isAbsolute(f) ? f : path.join(cwd, f);
      pages.push({
        file: abs,
        route: toRoutePath(abs),
        title: preferTitleFromName(abs),
      });
    }
  }

  return pages;
}

function gatherPages() {
  const inv = readJsonSafe(REPORTS_INV) || readJsonSafe(VAR_INV);
  if (inv) {
    const pages = normalizeInventory(inv);
    if (pages.length) return pages;
  }
  // Fallback: scan src/pages/**
  const files = scanPagesRoot();
  return files.map((abs) => ({
    file: abs,
    route: toRoutePath(abs),
    title: preferTitleFromName(abs),
  }));
}

function fileToImport(abs) {
  // Return import path like "@/pages/parametrage/Familles"
  const rel = path.relative(SRC_DIR, abs).replace(/\\/g, "/");
  const noExt = rel.replace(/\.(jsx|tsx|js|ts)$/, "");
  return "@/" + noExt;
}

function toChunkName(absFile) {
  const rel = path
    .relative(SRC_DIR, absFile)
    .replace(/\\/g, "/")
    .replace(/\.(jsx|tsx|js|ts)$/i, "");
  const normalized = rel
    .split("/")
    .filter(Boolean)
    .map((segment) => segment.replace(/[^a-zA-Z0-9]+/g, "-").toLowerCase())
    .join("-");
  return `page-${normalized || "root"}`;
}

function renderRouterTsx(pages) {
  // Only include routable pages that live under src/pages
  const routables = pages.filter((p) => p.file.includes(path.join("src", "pages")));
  // Stable ordering: by route path
  routables.sort((a, b) => a.route.localeCompare(b.route));

  const importBlocks = routables
    .map((p, i) => {
      const importFn = `const import_Page_${i} = () => import(/* webpackChunkName: "${toChunkName(
        p.file
      )}" */ "${fileToImport(p.file)}");`;
      const registerCall = `registerRoutePrefetch("${p.route}", import_Page_${i});`;
      const component = `const Page_${i} = lazy(import_Page_${i});`;
      return `${importFn}\n${registerCall}\n${component}`;
    })
    .join("\n");

  const routeObjs = routables
    .map((p, i) => `  { path: "${p.route}", element: <Page_${i} /> }`)
    .join(",\n");

  return `/* AUTO-GENERATED. Do not edit manually.
   * Generated by scripts/generate-navigation.cjs
   */
import React, { lazy } from "react";
import { registerRoutePrefetch } from "@/routerPrefetch";

${importBlocks}

export const routes = [
${routeObjs}
];
`;
}

function renderSidebarTsx(pages) {
  // Keep only top-level interesting entries for the menu
  // Simple heuristic: keep first segments unique & friendly
  const items = [];
  const seen = new Set();
  for (const p of pages) {
    const seg1 = p.route.split("/").filter(Boolean)[0] || "";
    const key = seg1 || p.route;
    if (seen.has(key)) continue;
    seen.add(key);
    items.push({ route: p.route, label: p.title });
  }
  // Keep deterministic order by label
  items.sort((a,b) => a.label.localeCompare(b.label));

  const links = items.map(it => 
    `        <li key="${it.route}">
          <NavLink to="${it.route}" className={({isActive}) => "block px-3 py-2 rounded hover:bg-muted " + (isActive ? "font-semibold" : "")}>
            ${it.label}
          </NavLink>
        </li>`
  ).join("\n");

  return `/* AUTO-GENERATED. Do not edit manually.
   * Generated by scripts/generate-navigation.cjs
   */
import React from "react";
import { NavLink } from "react-router-dom";

export default function SidebarAutogen() {
  return (
    <aside className="w-64 p-3 border-r border-border bg-background">
      <nav>
        <ul className="space-y-1">
${links}
        </ul>
      </nav>
    </aside>
  );
}
`;
}

function writeIfChanged(file, content) {
  let changed = true;
  if (fs.existsSync(file)) {
    const prev = fs.readFileSync(file, "utf8");
    if (prev === content) changed = false;
  } else {
    fs.mkdirSync(path.dirname(file), { recursive: true });
  }
  if (changed) {
    fs.writeFileSync(file, content, "utf8");
    console.log(`✔ UPDATED ${path.relative(cwd, file)}`);
  } else {
    console.log(`✓ UNCHANGED ${path.relative(cwd, file)}`);
  }
  return changed;
}

function main() {
  try {
    const pages = gatherPages();
    if (!pages.length) {
      console.error("✖ No pages found to generate routes/sidebar.");
      process.exit(1);
    }
    const router = renderRouterTsx(pages);
    const sidebar = renderSidebarTsx(pages);
    const ch1 = writeIfChanged(OUT_ROUTER, router);
    const ch2 = writeIfChanged(OUT_SIDEBAR, sidebar);

    console.log("\nSummary:");
    console.log(`  router.autogen.tsx: ${ch1 ? "updated" : "unchanged"}`);
    console.log(`  sidebar.autogen.tsx: ${ch2 ? "updated" : "unchanged"}`);
    console.log("\nNOTE:");
    console.log('  - Import routes with:  import { routes } from "@/router.autogen";');
    console.log('  - Import Sidebar with: import Sidebar from "@/components/sidebar.autogen";');
    process.exit(0);
  } catch (e) {
    console.error("[generate-navigation] Uncaught error:");
    console.error(e && e.stack || e);
    process.exit(1);
  }
}

main();
